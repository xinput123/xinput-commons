package io.github.xinput.commons;

/*
 * Copyright 1999-2101 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import io.github.xinput.commons.date.DateUtils;
import io.github.xinput.commons.exception.TypeException;

import java.lang.reflect.Array;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * 类型工具类.
 *
 * @author wenshao
 */
public class TypeHelper {

  public static final String castToString(Object value) {
    if (value == null) {
      return null;
    }

    return value.toString();
  }

  public static final Byte castToByte(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Number) {
      return ((Number) value).byteValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }
      return Byte.parseByte(strVal);
    }

    throw new TypeException("can not cast to byte, value : " + value);
  }

  public static final Character castToChar(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Character) {
      return (Character) value;
    }

    if (value instanceof String) {
      String strVal = (String) value;

      if (strVal.length() == 0) {
        return null;
      }

      if (strVal.length() != 1) {
        throw new TypeException("can not cast to byte, value : "
            + value);
      }

      return strVal.charAt(0);
    }

    throw new TypeException("can not cast to char, value : " + value);
  }

  public static final Short castToShort(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Number) {
      return ((Number) value).shortValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }
      return Short.parseShort(strVal);
    }

    throw new TypeException("can not cast to short, value : " + value);
  }

  public static final BigDecimal castToBigDecimal(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof BigDecimal) {
      return (BigDecimal) value;
    }

    if (value instanceof BigInteger) {
      return new BigDecimal((BigInteger) value);
    }

    String strVal = value.toString();
    if (strVal.length() == 0) {
      return null;
    }

    return new BigDecimal(strVal);
  }

  public static final BigInteger castToBigInteger(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof BigInteger) {
      return (BigInteger) value;
    }

    if (value instanceof Float || value instanceof Double) {
      return BigInteger.valueOf(((Number) value).longValue());
    }

    String strVal = value.toString();
    if (strVal.length() == 0) {
      return null;
    }

    return new BigInteger(strVal);
  }

  public static final Float castToFloat(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Number) {
      return ((Number) value).floatValue();
    }

    if (value instanceof String) {
      String strVal = value.toString();
      if (strVal.length() == 0) {
        return null;
      }

      return Float.parseFloat(strVal);
    }

    throw new TypeException("can not cast to float, value : " + value);
  }

  public static final Double castToDouble(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Number) {
      return ((Number) value).doubleValue();
    }

    if (value instanceof String) {
      String strVal = value.toString();
      if (strVal.length() == 0) {
        return null;
      }
      return Double.parseDouble(strVal);
    }

    throw new TypeException("can not cast to double, value : " + value);
  }

  public static final Date castToDate(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Calendar) {
      return ((Calendar) value).getTime();
    }

    if (value instanceof Date) {
      return (Date) value;
    }

    long longValue = 0;

    if (value instanceof Number) {
      longValue = ((Number) value).longValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;

      if (strVal.indexOf('-') != -1) {
        String format;
        if (DateUtils.DATE_TIME_FORMATTER_STRING.length() == strVal.length()) {
          format = DateUtils.DATE_TIME_FORMATTER_STRING;
        } else if (strVal.length() == 10) {
          format = DateUtils.DATE_FORMATTER_STRING;
        } else if (DateUtils.DATE_TIME_FORMATTER_STRING.length() == strVal.length()) {
          format = DateUtils.DATE_TIME_FORMATTER_STRING;
        } else {
          format = "yyyy-MM-dd HH:mm:ss.SSS";
        }

        SimpleDateFormat dateFormat = new SimpleDateFormat(format);
        try {
          return dateFormat.parse(strVal);
        } catch (ParseException e) {
          throw new TypeException("can not cast to Date, value : "
              + strVal);
        }
      }

      if (strVal.length() == 0) {
        return null;
      }

      longValue = Long.parseLong(strVal);
    }

    if (longValue <= 0) {
      throw new TypeException("can not cast to Date, value : " + value);
    }

    return new Date(longValue);
  }

  public static final java.sql.Date castToSqlDate(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Calendar) {
      return new java.sql.Date(((Calendar) value).getTimeInMillis());
    }

    if (value instanceof java.sql.Date) {
      return (java.sql.Date) value;
    }

    if (value instanceof Date) {
      return new java.sql.Date(((Date) value).getTime());
    }

    long longValue = 0;

    if (value instanceof Number) {
      longValue = ((Number) value).longValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }

      longValue = Long.parseLong(strVal);
    }

    if (longValue <= 0) {
      throw new TypeException("can not cast to SQL Date, value : "
          + value);
    }

    return new java.sql.Date(longValue);
  }

  public static final java.sql.Timestamp castToTimestamp(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Calendar) {
      return new java.sql.Timestamp(((Calendar) value).getTimeInMillis());
    }

    if (value instanceof java.sql.Timestamp) {
      return (java.sql.Timestamp) value;
    }

    if (value instanceof Date) {
      return new java.sql.Timestamp(((Date) value).getTime());
    }

    long longValue = 0;

    if (value instanceof Number) {
      longValue = ((Number) value).longValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }

      longValue = Long.parseLong(strVal);
    }

    if (longValue <= 0) {
      throw new TypeException("can not cast to Date, value : " + value);
    }

    return new java.sql.Timestamp(longValue);
  }

  public static final Long castToLong(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Number) {
      return ((Number) value).longValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }

      return Long.parseLong(strVal);
    }

    throw new TypeException("can not cast to long, value : " + value);
  }

  public static final Integer castToInt(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Integer) {
      return (Integer) value;
    }

    if (value instanceof Number) {
      return ((Number) value).intValue();
    }

    if (value instanceof String) {
      String strVal = (String) value;
      if (strVal.length() == 0) {
        return null;
      }

      return Integer.parseInt(strVal);
    }

    throw new TypeException("can not cast to int, value : " + value);
  }

  public static final Boolean castToBoolean(Object value) {
    if (value == null) {
      return null;
    }

    if (value instanceof Boolean) {
      return (Boolean) value;
    }

    if (value instanceof Number) {
      return ((Number) value).intValue() == 1;
    }

    if (value instanceof String) {
      String str = (String) value;
      if (str.length() == 0) {
        return null;
      }

      if ("true".equals(str)) {
        return Boolean.TRUE;
      }
      if ("false".equals(str)) {
        return Boolean.FALSE;
      }
      if ("yes".equals(str.toLowerCase())) {
        return Boolean.TRUE;
      }
      if ("no".equals(str.toLowerCase())) {
        return Boolean.FALSE;
      }

      if ("1".equals(str)) {
        return Boolean.TRUE;
      }
    }

    throw new TypeException("can not cast to boolean, value : " + value);
  }

  @SuppressWarnings("unchecked")
  public static final <T> T cast(Object obj, Class<T> clazz) {
    if (obj == null) {
      return null;
    }

    if (clazz == obj.getClass()) {
      return (T) obj;
    }

    if (obj instanceof Map) {
      if (clazz == Map.class) {
        return (T) obj;
      }

    }

    if (clazz.isAssignableFrom(obj.getClass())) {
      return (T) obj;
    }

    if (clazz == boolean.class || clazz == Boolean.class) {
      return (T) castToBoolean(obj);
    }

    if (clazz == byte.class || clazz == Byte.class) {
      return (T) castToByte(obj);
    }

    if (clazz == short.class || clazz == Short.class) {
      return (T) castToShort(obj);
    }

    if (clazz == int.class || clazz == Integer.class) {
      return (T) castToInt(obj);
    }

    if (clazz == long.class || clazz == Long.class) {
      return (T) castToLong(obj);
    }

    if (clazz == float.class || clazz == Float.class) {
      return (T) castToFloat(obj);
    }

    if (clazz == double.class || clazz == Double.class) {
      return (T) castToDouble(obj);
    }

    if (clazz == String.class) {
      return (T) castToString(obj);
    }

    if (clazz == BigDecimal.class) {
      return (T) castToBigDecimal(obj);
    }

    if (clazz == BigInteger.class) {
      return (T) castToBigInteger(obj);
    }

    if (clazz == Date.class) {
      return (T) castToDate(obj);
    }

    if (clazz == java.sql.Date.class) {
      return (T) castToSqlDate(obj);
    }

    if (clazz == java.sql.Timestamp.class) {
      return (T) castToTimestamp(obj);
    }

    if (Calendar.class.isAssignableFrom(clazz)) {
      Date date = castToDate(obj);
      Calendar calendar;
      if (clazz == Calendar.class) {
        calendar = Calendar.getInstance();
      } else {
        try {
          calendar = (Calendar) clazz.newInstance();
        } catch (Exception e) {
          throw new TypeException("can not cast to : "
              + clazz.getName(), e);
        }
      }
      calendar.setTime(date);
      return (T) calendar;
    }

    if (obj instanceof String) {
      String strVal = (String) obj;
      if (strVal.length() == 0) {
        return null;
      }
    }

    throw new TypeException("can not cast to : " + clazz.getName());
  }

  private static ConcurrentMap<String, Class<?>> mappings = new ConcurrentHashMap<String, Class<?>>();

  static {
    addBaseClassMappings();
  }

  public static void addClassMapping(String className, Class<?> clazz) {
    if (className == null) {
      className = clazz.getName();
    }

    mappings.put(className, clazz);
  }

  public static void addBaseClassMappings() {
    mappings.put("byte", byte.class);
    mappings.put("short", short.class);
    mappings.put("int", int.class);
    mappings.put("long", long.class);
    mappings.put("float", float.class);
    mappings.put("double", double.class);
    mappings.put("boolean", boolean.class);
    mappings.put("char", char.class);

    mappings.put("[byte", byte[].class);
    mappings.put("[short", short[].class);
    mappings.put("[int", int[].class);
    mappings.put("[long", long[].class);
    mappings.put("[float", float[].class);
    mappings.put("[double", double[].class);
    mappings.put("[boolean", boolean[].class);
    mappings.put("[char", char[].class);

    mappings.put(HashMap.class.getName(), HashMap.class);
  }

  public static void clearClassMapping() {
    mappings.clear();
    addBaseClassMappings();
  }

  public static Class<?> loadClass(String className) {
    if (className == null || className.length() == 0) {
      return null;
    }

    Class<?> clazz = mappings.get(className);

    if (clazz != null) {
      return clazz;
    }

    if (className.charAt(0) == '[') {
      Class<?> componentType = loadClass(className.substring(1));
      return Array.newInstance(componentType, 0).getClass();
    }

    boolean newClass = (className.length() > 0 && className.charAt(0) == 'L')
        && className.endsWith(StringHelper.SEMICOLON);
    if (newClass) {
      String newClassName = className
          .substring(1, className.length() - 1);
      return loadClass(newClassName);
    }

    try {
      clazz = Thread.currentThread().getContextClassLoader().loadClass(className);
      addClassMapping(className, clazz);
      return clazz;
    } catch (Throwable e) {
      // skip
    }

    try {
      clazz = Class.forName(className);
      addClassMapping(className, clazz);
      return clazz;
    } catch (Throwable e) {
      // skip
    }

    return clazz;
  }

  public static Class<?> getClass(Type type) {
    if (type.getClass() == Class.class) {
      return (Class<?>) type;
    }

    if (type instanceof ParameterizedType) {
      return getClass(((ParameterizedType) type).getRawType());
    }

    return Object.class;
  }
}

